<!DOCTYPE html>

<html lang="ja">

<head>
	<meta charset="UTF-8">
	<meta name="description" content="Let's move the block and let the light transmit!">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Transmit</title>

	<style>
		html, body {
			margin: 0;
			overflow: hidden;
			padding: 0;
		}

		#background {
			background-color: black;
			height: 100vh;
			width: 100vw;
		}

		#leftLaser, #rightLaser {
			background-color: darkred;
		}

		#foreground {
			background-color: white;
		}

		@media (min-aspect-ratio: 1/1) {
			#leftLaser {
				position: absolute;
				top: 41vh;
				left: calc((100vw - 60vh) / 2 - 2vh);
				height: 8vh;
				width: 2vh;
			}

			#rightLaser {
				position: absolute;
				top: 41vh;
				left: calc((100vw - 60vh) / 2 + 60vh);
				height: 8vh;
				width: 2vh;
			}

			#foreground {
				position: absolute;
				top: 20vh;
				left: calc((100vw - 60vh) / 2);
				height: 60vh;
				width: 60vh;
			}
		}

		@media (max-aspect-ratio: 1/1) {
			#leftLaser {
				position: absolute;
				top: calc((100vh - 60vw) / 2 + 21vw);
				left: 18vw;
				height: 8vw;
				width: 2vw;
			}

			#rightLaser {
				position: absolute;
				top: calc((100vh - 60vw) / 2 + 21vw);
				left: 80vw;
				height: 8vw;
				width: 2vw;
			}

			#foreground {
				position: absolute;
				top: calc((100vh - 60vw) / 2);
				left: 20vw;
				height: 60vw;
				width: 60vw;
			}
		}
	</style>
</head>

<body>
	<canvas id="background"></canvas>
	<canvas id="leftLaser"></canvas>
	<canvas id="rightLaser"></canvas>
	<canvas id="foreground"></canvas>
	<script>
		var block = [];
		let selectedBlock = null;
		let offsetX;
		let offsetY;
		let n;
		let finalBlock = null;
		let isGameClear = false;
		var color = ['aqua', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'purple', 'red', 'silver', 'teal', 'yellow'];
		var laser = [];

		class Block {
			constructor(x, y, width, height) {
				this.x = x;
				this.y = y;
				this.height = height;
				this.width = width;
			}

			drow() {
				const foreground = document.getElementById('foreground').getContext('2d');
				foreground.fillRect(this.x * n, this.y * n, this.width * n, this.height * n);
			}
		}

		function checkNoBlock(x, y, width, height) {
			for(let i = 0; i < block.length; i ++) {
				if(!(x >= block[i].x + block[i].width || x + width <= block[i].x)) {
					return false;
				}
				if(!(y >= block[i].y + block[i].height || y + height <= block[i].y)) {
					return false;
				}
			}
			return true;
		}

		function drow() {
			const foreCanvas = document.getElementById('foreground')
			const foreground = foreCanvas.getContext('2d');
			foreCanvas.width = foreCanvas.offsetWidth;
			foreCanvas.height = foreCanvas.offsetHeight;
			foreground.clearRect(0, 0, foreground.width, foreground.height);
			for(let i = 0; i < block.length; i ++) {
				foreground.fillStyle = color[i];
				block[i].drow();
			}
			foreground.fillStyle = "orangered";
			for(let i = 0; i < 6; i ++) {
				if(laser[i] === true) {
					break;
				}
				foreground.fillRect(i * n, 2.4 * n, n, 0.2 * n);
			}
			for(let i = 5; i >= 0; i --) {
				if(laser[i] === true) {
					break;
				}
				foreground.fillRect(i * n, 2.4 * n, n, 0.2 * n);
			}
			if(laser.every(l => l === false)) {
				isGameClear = true;
				let count = 0;
				let intervalId = setInterval(() => {
					foreground.beginPath();
					foreground.arc(finalBlock * n, 2.5 * n, count, 0, 2 * Math.PI, false);
					foreground.fillStyle = 'orangered';
					foreground.fill();
					if(Math.sqrt((finalBlock > 3 ? finalBlock : (6 - finalBlock)) ** 2 + 3.5 ** 2) * n < count) {
						clearInterval(intervalId);
						foreground.font = `${n}px Arial`;
						foreground.fillStyle = 'black';
						foreground.fillText('Game Clear', (6 * n - foreground.measureText('Game Clear').width) / 2, 3 * n);
					}
					count ++;
				}, 5);
			}
		}

		function setBlock() {
			for(let i = color.length - 1; i > 0; i --) {
				j = Math.random() * color.length | 0;
				temp = color[i];
				color[i] = color[j];
				color[j] = temp;
			}

			blockLength = Math.floor(Math.random() * 6) + 6;
			for(let i = 0; i < blockLength; i ++) {
				switch(Math.floor(Math.random() * 2)) {
					case 0:
						block[i] = new Block(Math.floor(Math.random() * 6), 0, 1, 0);
						switch(Math.floor(Math.random() * 3)) {
							case 0:
								block[i].y = 0;
								block[i].height = 2;
								break;
							case 1:
								block[i].y = 3;
								if(Math.floor(Math.random() * 2) == 0) {
									block[i].height = 2;
								} else {
									block[i].height = 3;
								}
								break;
							case 2:
								block[i].y = 4;
								block[i].height = 2;
								break;
						}
						break;
					case 1:
						block[i] = new Block(Math.floor(Math.random() * 5), Math.floor(Math.random() * 5), 0, 1);
						block[i].y = block[i].y == 2 ? 5 : block[i].y;
						if(block[i].x == 4) {
							block[i].width = 2;
						} else {
							if(Math.floor(Math.random() * 2) == 0) {
								block[i].width = 2;
							} else {
								block[i].width = 3;
							}
						}
						break;
				}
				if(!checkNoBlock(block[i].x, block[i].y, block[i].width, block[i].height)) {
					i --;
				}
			}
			for(let i = 0; i < 1000; i ++) {
				let b = block[Math.floor(Math.random() * block.length)];
				if(b.width == 1) {
					let canUp = true;
					let canDown = true;
					if(b.y == 0) {
						if(!checkNoBlock(block.x, block.y - 1, 1, 1)) {
							canUp = false;
						}
					} else {
						canDown = false;
					}
					if(b.y == 5) {
						if(!checkNoBlock(block.x, block.y + 1, 1, 1)) {
							canDown = false;
						}
					} else {
						canDown = false;
					}
					if(canUp && !canDown) {
						b.y --;
					} else if(!canUp && canDown) {
						b.y ++;
					} else if(canUp && canDown) {
						if(Math.floor(Math.random() * 2) == 0) {
							b.y --;
						} else {
							b.y ++;
						}
					}
				} else {
					let canLeft = true;
					let canRight = true;
					if(b.x == 0) {
						if(!checkNoBlock(b.x - 1, b.y, 1, 1)) {
							canLeft = false;
						}
					} else {
						canLeft = false;
					}
					if(b.x == 5) {
						if(!checkNoBlock(b.x + 1, b.y, 1, 1)) {
							canRight = false;
						}
					} else {
						canRight = false;
					}
					if(canLeft && !canRight) {
						b.x --;
					} else if(!canLeft && canRight) {
						b.x ++;
					} else if(canLeft && canRight) {
						if(Math.floor(Math.random() * 2) == 0) {
							b.x --;
						} else {
							b.x ++;
						}
					}
				}
			}

			for(let i = 0; i < 6; i ++) {
				laser[i] = false;
			}
			block.forEach(b => {
				if(b.y <= 2 && b.y + b.height >= 3) {
					for(let i = b.x; i < b.x + b.width; i ++) {
						laser[i] = true;
					}
				}
			});
		}

		document.getElementById('foreground').addEventListener('pointerdown', (e) => {
			if(isGameClear) {
				isGameClear = false;
				block = [];
				setBlock();
				return;
			}
			const rect = e.target.getBoundingClientRect();
			const x = (e.clientX - rect.left) / n;
			const y = (e.clientY - rect.top) / n;
			block.forEach(b => {
				if (x >= b.x && x <= b.x + b.width && y >= b.y && y <= b.y + b.height) {
					selectedBlock = b;
					offsetX = x -  b.x;
					offsetY = y - b.y;
				}
			});
		});

		window.addEventListener('load', () => {
			n = document.getElementById('foreground').offsetWidth / 6;
			setBlock();
			drow();
		});

		document.addEventListener('pointermove', (e) => {
			e.preventDefault();
			if (!selectedBlock || isGameClear) {
				return;
			}
			const rect = document.getElementById('foreground').getBoundingClientRect();
			if(selectedBlock.height == 1) {
				let x = (e.clientX - rect.left) / n - offsetX;
				if(0 > x || x + selectedBlock.width > 6) {
					return;
				}
				for(let i = 0; i < block.length; i ++) {
					const b = block[i];
					if(b === selectedBlock) {
						continue;
					}
					const overlapX = x < b.x + b.width && x + selectedBlock.width > b.x;
					const overlapY = selectedBlock.y < b.y + b.height && selectedBlock.y + selectedBlock.height > b.y;
					if(overlapX && overlapY) {
						return;
					}
				}
				selectedBlock.x = x;
			} else {
				let y = (e.clientY - rect.top) / n - offsetY;
				if(0 > y || y + selectedBlock.height > 6) {
					return;
				}
				for(let i = 0; i < block.length; i ++) {
					const b = block[i];
					if(b === selectedBlock) {
						continue;
					}
					const overlapX = selectedBlock.x < b.x + b.width && selectedBlock.x + selectedBlock.width > b.x;
					const overlapY = y < b.y + b.height && y + selectedBlock.height > b.y;
					if(overlapX && overlapY) {
						return;
					}
				}
				if(y > 2.6 || y + selectedBlock.height < 2.4) {
					let isFinalBlock = 0;
					laser.forEach(l => {
						if(l === true) {
							isFinalBlock ++;
						}
					});
					if(isFinalBlock === 1) {
						finalBlock = selectedBlock.x + selectedBlock.width / 2;
					}
					laser[selectedBlock.x] = false;
				} else {
					laser[selectedBlock.x] = true;
				}
				selectedBlock.y = y;
			}
			drow();
		}, {
			passive: false
		});

		document.addEventListener('pointerup', () => {
			if(selectedBlock && !isGameClear) {
				selectedBlock.x = Math.floor(selectedBlock.x + 0.5);
				selectedBlock.y = Math.floor(selectedBlock.y + 0.5);
				selectedBlock = null;
				drow();
			}
		});

		window.addEventListener('resize', () => {
			n = document.getElementById('foreground').offsetWidth / 6;
			drow();
		});
	</script>
</body>

</html>
